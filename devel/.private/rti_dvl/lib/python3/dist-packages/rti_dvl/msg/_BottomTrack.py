# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from rti_dvl/BottomTrack.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import geometry_msgs.msg
import rti_dvl.msg
import std_msgs.msg

class BottomTrack(genpy.Message):
  _md5sum = "e236d20adc4e75be05aff82938ad572b"
  _type = "rti_dvl/BottomTrack"
  _has_header = True  # flag to mark the presence of a Header object
  _full_text = """Header header
rti_dvl/Command command

# Sample number
uint64 sample
# Start time of the sample in second
float64 time
# Velocity in m/s in body frame
geometry_msgs/Vector3 velocity
# Orientation (roll, pitch, yaw) at the sample
geometry_msgs/Vector3 orientation
# Temperature in Celsius
float64 temperature
# Depth below transducer in m
float64 altitude
# Pressure in BAR
float64 pressure

================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id

================================================================================
MSG: rti_dvl/Command
# Subsystem Configuration
# 3: 600 kHz 4 beam 20 degree piston
string CEPO 

# CEAUTOSTART On/OFF
# 0	OFF
# 1	DO NOT USE
# 2	RS232
# 3	RS485
# 4	RS422
# 5	EMAC
# 6	UDP
string CEAUTOSTART

# Ensemble output period in HH:MM:SS.hh
string CEI

# Output format
# [1] - RoweTech Binary (RTB)
# [1] - RoweTech DVL (RTD)
# [2] - ASCII Format
# [2] - DVL Format
# [3] - NMEA Status String
# [4] - Ocean Server NMEA DVL Format
# [5] - DVL Format
# [100] - PD0
# [103] - PD3 Binary Format
# [104] - PD4 Binary Format
# [105] - PD5 Binary Format
# [106] - PD6 ASCII Format
# [113] - PD13 ASCII Format
string C485OUT 
string C232OUT 

# 1 - Turn ON Bottom Tracking
# 0 - Turn OFF Bottom Tracking
string CBTON

# Bottom Track Broadband. Sets Bottom Track coded pulse transmission and lag.
# n, m, d, x
# [n] - Transmit Pulse Type and Processing
#     0 = Narrowband.
#     Provides long range profiles at the expense of variance.
#     Not recommended for use with bin size less than the default bin size.
#     1 = Broadband.
#     Typically 15% less range than narrow band but has greatly reduced variance (depending on lag length).
#     Used in conjunction with CWPBP for small bins.
#     2 = Un-coded Broadband (no ambiguity resolver).
#     Non-coded has slightly higher variance than the coded transmit without the annoying autocorrelation side peaks. Better for small bins.
#     4 = Non Coded Broadband pulse-to-pulse (no ambiguity resolver).
#     Provides ultra low variance for small bin sizes.
#     7 = Auto Switch (n=0, n=2, n=4)
# [m] - Lag length in vertical meters (m)
#     The lag length will set the maximum velocity the ADCP can read. A rule of thumb is to set the lag length, where 1.5 is a 'safety factor'.    
# [d] - Long Range Narrowband Auto Switch Depth (m)
#     The depth to switch from Broadband to Narrowband in meters. This is used in the Auto Switch mode.
# [x] - Beam Multiplex
#     1 = ping and process each beam one at a time.
#     2 = ping and process beam pairs.
#     4 = ping and process all four beams together.
string CBTBB

# Set the maximum depth to search for the bottom. This will reduce the amount of time in the search algorithm.
string CBTMX

# Blanking distance for the Bottom Track ping. This is the area that will be ignored just after the ADCP.
# n.nn, m.mm
#     [n.nn] - 0 to 10 meters. Sets the vertical distance from the face of the transducer at which the bottom detection algorithm begins searching for the bottom when range to the bottom is LESS than CBTT parameter b.
#     [m.mm] - 0 to 300 meters. Sets the vertical distance from the face of the transducer at which the bottom detection algorithm begins searching for the bottom when range to the bottom is GREATER than CBTT parameter b.
string CBTBL

# Bottom Track thresholds.
# a,b,c,d
#     [a] - SNR (dB) Shallow Detection Threshold. SNR(dB) shallow detection threshold. Lowering the SNR counts "a" and/or "c" will allow to the DVL to detect smaller bottom echo at greater range. The consequence is that DVL may false detect the bottom at the wrong range when the bottom signal is weak.
#     [b] - Depth(m) Shallow Switch. Depth(m) at which the bottom track switches from using the shallow to the deep SNR. Conditions in shallow water (high backscatter) can be different than deep water so "b" allows for two different SNR settings one for shallow ("a") and one for deep ("c").
#     [c] - SNR(dB) Deep Detection Threshold. SNR(dB) deep detection threshold. Lowering the SNR counts "a" and/or "c" will allow to the DVL to detect smaller bottom echo at greater range. The consequence is that DVL may false detect the bottom at the wrong range when the bottom signal is weak.
#     [d] - Depth(m) Deep Switch. Depth(m) at which the bottom track switches from low to high gain receive. The ADCP/DVL has a high power transmitter. In shallow water the bottom echo may saturate the receiver input. While this does not harm the system saturation limits the measurable signal level of the bottom echo which can make it difficult to detect the bottom in a high water backscatter environment. The ADCP/DVL places the receiver in low gain when the depth is below the "d" parameter setting. The change in gain is about 40 dB. If you observe the ADCP/DVL having difficulty detecting the bottom near the "d" setting you may need set "d" to a deeper or more shallow depth depending on the depth where the detection is poor. A good rule to follow is a strong bottom echo requires a larger value in d and a weak bottom echo a smaller value.
string CBTT

# Not used for bottom tracking only
# This is used to create a pause between the Water Profile and Bottom Track ping. This will allow the Bottom Track ping to die down if it is reverberating and causing interference in the Water Profile ping.
string CBTTBP

# Set thresholds to mark the data bad. This will give 3 options of forcing data to be bad. This can also be used to make all the data good by settings all the thresholds to 0.
# c.cc,q.qq,v.vv
#     [c.cc] - Correlation threshold.
#     [q.qq] - Error Velocity threshold. Range: m/s
#     [v.vv] - Velocity threshold. Range: m/s
string CBTST

# Low pass filtering helps reduce velocity measurement noise
# a,b,c,d,e
# We do not recommend that the filter be enabled.
string CBTFILT

# Water Speed of Sound Control.
# 1, 2, 3, 4
#     [1] - Water Temperature Source
#     [2] - Transducer Depth Source
#     [3] - Salinity Source
#     [4] - Speed of Sound Source
# Choices
#     0 = Command
#     1 = Sensor
#     2 = Internal Calculation.
string CWSSC

# Water Salinity (ppt). Used in the water speed of sound calculation
string CWS

# Water Temperature (degrees celsius). Used in the water speed of sound calculation if the temperature sensor is not available.
string CWT

# Transducer Depth (meters). Used in the water speed of sound calculation.
string CTD

# Water Speed of Sound (meters per second).
string CWSS

# This will set the heading offset for the ADCP. The heading offset will be applied to the heading value before it is to be used within the system for calculations. Typically only the first value is given.
string CHO
# Heading source. Used to state whether to use no heading, internal compass heading or GPS heading. This value should be set to GPS HDT if you cannot calibrate the compass in its environment.
string CHS
# Tilt Source. Set whether to use the tilt from internal compass or no tilt.
string CTS

# Velocity Scale Factor
#  n.nn, m.mm
#     [n.nn] - Water Velocity Scale Factor
#     [m.mm] - Bottom Track Scale Factor
string CVSF

================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z"""
  __slots__ = ['header','command','sample','time','velocity','orientation','temperature','altitude','pressure']
  _slot_types = ['std_msgs/Header','rti_dvl/Command','uint64','float64','geometry_msgs/Vector3','geometry_msgs/Vector3','float64','float64','float64']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,command,sample,time,velocity,orientation,temperature,altitude,pressure

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(BottomTrack, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.command is None:
        self.command = rti_dvl.msg.Command()
      if self.sample is None:
        self.sample = 0
      if self.time is None:
        self.time = 0.
      if self.velocity is None:
        self.velocity = geometry_msgs.msg.Vector3()
      if self.orientation is None:
        self.orientation = geometry_msgs.msg.Vector3()
      if self.temperature is None:
        self.temperature = 0.
      if self.altitude is None:
        self.altitude = 0.
      if self.pressure is None:
        self.pressure = 0.
    else:
      self.header = std_msgs.msg.Header()
      self.command = rti_dvl.msg.Command()
      self.sample = 0
      self.time = 0.
      self.velocity = geometry_msgs.msg.Vector3()
      self.orientation = geometry_msgs.msg.Vector3()
      self.temperature = 0.
      self.altitude = 0.
      self.pressure = 0.

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CEPO
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CEAUTOSTART
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CEI
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.C485OUT
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.C232OUT
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CBTON
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CBTBB
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CBTMX
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CBTBL
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CBTT
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CBTTBP
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CBTST
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CBTFILT
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CWSSC
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CWS
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CWT
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CTD
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CWSS
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CHO
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CHS
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CTS
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CVSF
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_Q10d().pack(_x.sample, _x.time, _x.velocity.x, _x.velocity.y, _x.velocity.z, _x.orientation.x, _x.orientation.y, _x.orientation.z, _x.temperature, _x.altitude, _x.pressure))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.command is None:
        self.command = rti_dvl.msg.Command()
      if self.velocity is None:
        self.velocity = geometry_msgs.msg.Vector3()
      if self.orientation is None:
        self.orientation = geometry_msgs.msg.Vector3()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CEPO = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CEPO = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CEAUTOSTART = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CEAUTOSTART = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CEI = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CEI = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.C485OUT = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.C485OUT = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.C232OUT = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.C232OUT = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CBTON = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CBTON = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CBTBB = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CBTBB = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CBTMX = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CBTMX = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CBTBL = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CBTBL = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CBTT = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CBTT = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CBTTBP = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CBTTBP = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CBTST = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CBTST = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CBTFILT = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CBTFILT = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CWSSC = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CWSSC = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CWS = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CWS = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CWT = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CWT = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CTD = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CTD = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CWSS = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CWSS = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CHO = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CHO = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CHS = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CHS = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CTS = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CTS = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CVSF = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CVSF = str[start:end]
      _x = self
      start = end
      end += 88
      (_x.sample, _x.time, _x.velocity.x, _x.velocity.y, _x.velocity.z, _x.orientation.x, _x.orientation.y, _x.orientation.z, _x.temperature, _x.altitude, _x.pressure,) = _get_struct_Q10d().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CEPO
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CEAUTOSTART
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CEI
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.C485OUT
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.C232OUT
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CBTON
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CBTBB
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CBTMX
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CBTBL
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CBTT
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CBTTBP
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CBTST
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CBTFILT
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CWSSC
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CWS
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CWT
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CTD
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CWSS
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CHO
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CHS
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CTS
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.command.CVSF
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_Q10d().pack(_x.sample, _x.time, _x.velocity.x, _x.velocity.y, _x.velocity.z, _x.orientation.x, _x.orientation.y, _x.orientation.z, _x.temperature, _x.altitude, _x.pressure))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.command is None:
        self.command = rti_dvl.msg.Command()
      if self.velocity is None:
        self.velocity = geometry_msgs.msg.Vector3()
      if self.orientation is None:
        self.orientation = geometry_msgs.msg.Vector3()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CEPO = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CEPO = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CEAUTOSTART = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CEAUTOSTART = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CEI = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CEI = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.C485OUT = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.C485OUT = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.C232OUT = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.C232OUT = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CBTON = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CBTON = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CBTBB = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CBTBB = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CBTMX = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CBTMX = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CBTBL = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CBTBL = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CBTT = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CBTT = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CBTTBP = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CBTTBP = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CBTST = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CBTST = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CBTFILT = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CBTFILT = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CWSSC = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CWSSC = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CWS = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CWS = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CWT = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CWT = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CTD = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CTD = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CWSS = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CWSS = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CHO = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CHO = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CHS = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CHS = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CTS = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CTS = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.command.CVSF = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.command.CVSF = str[start:end]
      _x = self
      start = end
      end += 88
      (_x.sample, _x.time, _x.velocity.x, _x.velocity.y, _x.velocity.z, _x.orientation.x, _x.orientation.y, _x.orientation.z, _x.temperature, _x.altitude, _x.pressure,) = _get_struct_Q10d().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_3I = None
def _get_struct_3I():
    global _struct_3I
    if _struct_3I is None:
        _struct_3I = struct.Struct("<3I")
    return _struct_3I
_struct_Q10d = None
def _get_struct_Q10d():
    global _struct_Q10d
    if _struct_Q10d is None:
        _struct_Q10d = struct.Struct("<Q10d")
    return _struct_Q10d
